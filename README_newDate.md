# `new Date()` в JavaScript

В JavaScript объект `Date` используется для работы с датами и временем. Метод `new Date()` создает новый объект `Date`, который представляет текущее время и дату.

## Создание объекта `Date`

### 1. Без параметров
Когда `new Date()` вызывается без параметров, он создает объект с текущими датой и временем.

```javascript
let currentDate = new Date();
console.log(currentDate); // Выведет текущую дату и время
```
### 2. С параметром (строка)
Если передать строку в формате даты, new Date() создаст объект Date, представляющий эту дату.

```javascript
let specificDate = new Date('2025-01-01');
console.log(specificDate); // Выведет: Thu Jan 01 2025 00:00:00 GMT+0000 (UTC)
```
### 3. С параметром (числа)
Можно также передать число, представляющее количество миллисекунд, прошедших с 1 января 1970 года (время в UTC).

```javascript
let dateFromMilliseconds = new Date(1609459200000);
console.log(dateFromMilliseconds); // Выведет: Fri Jan 01 2021 00:00:00 GMT+0000 (UTC)
```
### 4. С параметрами (год, месяц, день, час, минута, секунда, миллисекунда)
Вы можете указать отдельные компоненты даты и времени в виде аргументов.

``` javascript
let customDate = new Date(2025, 0, 1, 12, 30, 0, 0);
console.log(customDate); // Выведет: Wed Jan 01 2025 12:30:00 GMT+0000 (UTC)
// 2025, Год: 2025
// 0, Месяц: январь  
// 1, День: 1-е число месяца
// 12, Часы: 12 часов дня
// 30, Минуты: 30 минут
// 0,Секунды: 0 секунд
// 0 Миллисекунды: 0 миллисекунд
```
- Примечание: Месяцы начинаются с 0 (0 — январь, 1 — февраль и т.д.).

## Методы объекта Date
- getFullYear() — возвращает полный год (например, 2025).
- getMonth() — возвращает месяц (от 0 до 11).
- getDate() — возвращает день месяца (от 1 до 31).
- getDay() — возвращает день недели как число от 0 до 6, где 0 — это воскресенье, 1 — понедельник, и так далее.
- getHours() — возвращает часы (от 0 до 23).
- getMinutes() — возвращает минуты (от 0 до 59).
- getSeconds() — возвращает секунды (от 0 до 59).
- getMilliseconds() — возвращает миллисекунды (от 0 до 999).
- getTime() — возвращает количество миллисекунд с 1 января 1970 года.

##### Пример использования:
```javascript
let currentDate = new Date();
console.log(currentDate.getFullYear()); // Текущий год
console.log(currentDate.getMonth()); // Текущий месяц
console.log(currentDate.getDate()); // Текущий день
console.log(currentDate.getHours()); // Текущий час
```
#### Форматирование даты
Чтобы отформатировать объект Date в строку, можно использовать метод .toLocaleDateString() или .toLocaleString() для получения строки в локализованном формате:

```javascript
let currentDate = new Date();
console.log(currentDate.toLocaleDateString()); // Например: "01/02/2025"
console.log(currentDate.toLocaleString()); // Например: "1/2/2025, 10:30:00"
```
## Методы set объекта Date:
- setFullYear(year, month, day) — устанавливает полный год, месяц и день.
- setMonth(month, day) — устанавливает месяц и день.
- setDate(day) — устанавливает день месяца.
- setHours(hours, minutes, seconds, milliseconds) — устанавливает часы, минуты, секунды и миллисекунды.
- setMinutes(minutes, seconds, milliseconds) — устанавливает минуты, секунды и миллисекунды.
- setSeconds(seconds, milliseconds) — устанавливает секунды и миллисекунды.
- setMilliseconds(milliseconds) — устанавливает миллисекунды.
- setTime(milliseconds) — устанавливает время, указанное в миллисекундах с 1 января 1970 года.

Пример использования методов set:
```javascript
let customDate = new Date(2025, 0, 1, 12, 30, 0, 0);

console.log("Исходная дата: " + customDate); 
// Выведет: Wed Jan 01 2025 12:30:00 GMT+0000 (UTC)

customDate.setFullYear(2026); 
console.log("После setFullYear: " + customDate); 
// Выведет: Fri Jan 01 2026 12:30:00 GMT+0000 (UTC)

customDate.setMonth(5); // Установим июнь (месяц 5)
console.log("После setMonth: " + customDate); 
// Выведет: Mon Jun 01 2026 12:30:00 GMT+0000 (UTC)

customDate.setDate(15); 
console.log("После setDate: " + customDate); 
// Выведет: Mon Jun 15 2026 12:30:00 GMT+0000 (UTC)

customDate.setHours(9, 45, 30, 500); 
console.log("После setHours: " + customDate); 
// Выведет: Mon Jun 15 2026 09:45:30 GMT+0000 (UTC)

customDate.setMinutes(50); 
console.log("После setMinutes: " + customDate); 
// Выведет: Mon Jun 15 2026 09:50:30 GMT+0000 (UTC)

customDate.setSeconds(45); 
console.log("После setSeconds: " + customDate); 
// Выведет: Mon Jun 15 2026 09:50:45 GMT+0000 (UTC)

customDate.setMilliseconds(250); 
console.log("После setMilliseconds: " + customDate); 
// Выведет: Mon Jun 15 2026 09:50:45 GMT+0000 (UTC)

customDate.setTime(1735734600000); // Установим дату по миллисекундам
console.log("После setTime: " + customDate); 
// Выведет: Fri Jan 01 2021 00:00:00 GMT+0000 (UTC)
```
#### Объяснение методов:
- setFullYear(year, month, day) — устанавливает год, месяц и день (если month и day не указаны, они остаются без изменений).
- setMonth(month, day) — устанавливает месяц и день (если day не указан, используется текущий день).
- setDate(day) — устанавливает день месяца.
- setHours(hours, minutes, seconds, milliseconds) — устанавливает часы, минуты, секунды и миллисекунды.
- setMinutes(minutes, seconds, milliseconds) — устанавливает минуты, секунды и миллисекунды.
- setSeconds(seconds, milliseconds) — устанавливает секунды и миллисекунды.
- setMilliseconds(milliseconds) — устанавливает миллисекунды.
- setTime(milliseconds) — устанавливает время в миллисекундах с 1 января 1970 года.

# Методы map объекта Date:
Метод Map в JavaScript представляет собой коллекцию пар ключ-значение, где ключи могут быть любого типа (не только строки и символы, как в обычных объектах). Коллекция Map позволяет эффективно добавлять, удалять, искать и перебирать пары ключ-значение.

### Основные методы Map:
- set(key, value) — добавляет пару ключ-значение в объект Map.
- get(key) — получает значение по ключу.
- has(key) — проверяет, существует ли ключ в объекте Map.
- delete(key) — удаляет пару ключ-значение по ключу.
- clear() — очищает весь Map, удаляя все ключи и значения.
- size — свойство, которое возвращает количество пар ключ-значение в Map.
- forEach(callback) — выполняет переданную функцию для каждой пары ключ-значение в Map.
Пример использования Map:
```javascript
// Создание нового Map
let myMap = new Map();

// Добавление пар ключ-значение
myMap.set('name', 'Alice');
myMap.set('age', 30);
myMap.set('job', 'developer');

console.log("Размер Map:", myMap.size);  // Выведет: 3

// Получение значения по ключу
console.log("Имя:", myMap.get('name'));  // Выведет: Alice

// Проверка наличия ключа
console.log("Есть ли ключ 'age'? ", myMap.has('age'));  // Выведет: true
console.log("Есть ли ключ 'address'? ", myMap.has('address'));  // Выведет: false

// Удаление пары по ключу
myMap.delete('job');
console.log("Размер Map после удаления:", myMap.size);  // Выведет: 2

// Очистка Map
myMap.clear();
console.log("Размер Map после очистки:", myMap.size);  // Выведет: 0

// Повторное добавление данных в Map
myMap.set('name', 'Bob');
myMap.set('age', 25);

// Перебор всех пар ключ-значение
myMap.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});
// Выведет:
// name: Bob
// age: 25
```
#### Объяснение методов:
- `new Map()` — создает новый Map
- `set(key, value)` — добавляет пару ключ-значение в Map. Если ключ уже существует, его значение будет обновлено.
- `get(key)` — возвращает значение, связанное с ключом, или undefined, если ключ не найден.
- `has(key)` — возвращает true, если ключ существует в Map, и false в противном случае.
- `delete(key)` — удаляет пару по ключу.
- `clear()` — удаляет все пары в Map.
- `size` — возвращает количество элементов в Map.
- `forEach(callback)` — выполняет функцию callback для каждой пары в Map. Функция принимает два аргумента: значение и ключ.

### Преимущества Map:
Ключи могут быть любыми типами данных (не только строки).
Элементы в Map сохраняют порядок вставки.
Методы поиска и добавления в Map работают быстрее, чем у обычных объектов.

### Разница между Object и map

#### Object
1. Типы ключей: Ключи могут быть только строками или символами.
2. Порядок элементов: Порядок не всегда гарантируется (может зависеть от реализации).
3. Методы для работы с элементами: Нет встроенных методов для добавления, удаления или получения элементов.
4. Производительность: Может быть менее эффективным при большом количестве элементов.
Перебор элементов: Требует использования for...in или `Object.keys(), Object.values(), Object.entries()`.
5. Количество элементов: Нет свойства, показывающего количество элементов.
6. Наследование: Наследует от `Object.prototype`, что может влиять на работу с данными.
7. Типы данных в качестве значений: Может использоваться только для хранения значений, которые являются данными.
8. Преобразование в массив: Для преобразования используется `Object.entries(), Object.keys(), Object.values()`.
9. Использование в качестве ассоциативных массивов: Используется как ассоциативный массив, но с ограничением на строковые ключи.

### Map
1. Типы ключей: Ключи могут быть любого типа (строки, числа, объекты и т.д.).
2. Порядок элементов: Порядок элементов всегда сохраняется в том порядке, в котором они были добавлены.
3. Методы для работы с элементами: Имеет методы set(), `get()`, `has()`, `delete()`, `clear()`.
4. Производительность: Более оптимизирован для работы с большим количеством элементов.
5. Перебор элементов: Имеет встроенные методы для перебора: `forEach()`, `keys()`, `values()`, `entries()`.
6. Количество элементов: Имеет свойство `size`, которое возвращает количество элементов.
7. Наследование: Не наследует от `Object.prototype`, не имеет встроенных свойств или методов.
8. Типы данных в качестве значений: Может хранить любые типы данных, включая другие объекты.
9. Преобразование в массив: Может быть преобразован в массив с помощью `Array.from()` или методов `entries()`, `keys()`, `values()`.
10. Использование в качестве ассоциативных массивов: Идеален для использования как ассоциативный массив с любыми типами ключей.

# new Set()
Set — это встроенный объект в JavaScript, который позволяет хранить уникальные значения любого типа, будь то примитивы или объекты. Основная особенность Set заключается в том, что он автоматически удаляет дубликаты, обеспечивая, чтобы все элементы в нем были уникальными.

### Основные особенности Set
1. Типы элементов:
- Set может хранить значения любого типа — строки, числа, объекты и другие примитивы, но каждый элемент должен быть уникальным.

2. Порядок элементов:
- Порядок элементов сохраняется в том виде, в котором они были добавлены.

3. Методы для работы с элементами:

- `add(value)` — добавляет элемент в Set.
- `delete(value)` — удаляет элемент из Set.
- `has(value)` — проверяет, есть ли элемент в Set.
- `clear()` — удаляет все элементы из Set.

Производительность:
- Set оптимизирован для работы с уникальными элементами и быстрой проверкой наличия элемента.

Перебор элементов:
- Set предоставляет методы для перебора элементов:

`forEach(callback)` — выполняет функцию для каждого элемента в Set.
`keys()` — возвращает итератор для всех элементов.
`values()` — возвращает итератор для всех значений в Set.
`entries()` — возвращает итератор для пар ключ-значение (в Set это просто значение, которое является и ключом, и значением).
- Количество элементов:
Свойство size возвращает количество элементов в Set.

Наследование:
- Set наследует от Object.prototype, но не имеет встроенных методов для работы с ключами, как Map.

Типы данных в качестве значений:
- Все элементы уникальны, дубликаты не допускаются, даже если добавлен тот же элемент.

Преобразование в массив:
- Set можно преобразовать в массив с помощью Array.from() или оператора распространения (...).

Использование:
- Идеален для работы с коллекцией уникальных значений.

Пример работы с Set
```javascript
// Создание нового Set
const mySet = new Set();

// Добавление элементов
mySet.add(1);
mySet.add(2);
mySet.add(3);

// Попытка добавить дубликат
mySet.add(2); // Игнорируется, так как элемент уже существует

// Проверка на наличие элемента
console.log(mySet.has(1)); // true
console.log(mySet.has(4)); // false

// Удаление элемента
mySet.delete(2);

// Получение количества элементов
console.log(mySet.size); // 2

// Перебор элементов
mySet.forEach(value => {
  console.log(value); // 1, 3
});

// Преобразование в массив
const myArray = Array.from(mySet);
console.log(myArray); // [1, 3]
```
#### Методы Set
- `add(value)` — добавляет элемент в Set.
- `delete(value)` — удаляет элемент из Set.
- `has(value)` — проверяет, есть ли элемент в Set.
- `clear()` — удаляет все элементы из Set.
- `forEach(callback)` — перебирает все элементы.
- `keys()` — возвращает итератор для всех элементов.
- `values()` — возвращает итератор для всех значений.
- `entries()` — возвращает итератор для пар ключ-значение.
Преобразование Set в массив
```javascript
// Преобразование Set в массив с помощью Array.from()
const myArray = Array.from(mySet);

// Преобразование Set в массив с использованием оператора распространения
const myArray2 = [...mySet];
```
Этот список и примеры показывают, как использовать Set для работы с уникальными значениями и что делает этот объект полезным в JavaScript.