# Рекурсия в JavaScript

**Рекурсия** — это техника программирования, при которой функция вызывает саму себя для решения задачи. Каждый рекурсивный вызов функции решает подзадачу, а базовый случай (условие выхода) останавливает рекурсию.

## Принципы рекурсии
1. **Базовый случай** (условие выхода): определяет, когда функция должна перестать вызывать саму себя.
2. **Рекурсивный случай**: определяет, как разделить задачу на более простые подзадачи.

## Пример: Факториал числа
Факториал числа `n` вычисляется как `n! = n * (n-1) * (n-2) * ... * 1`.

### Реализация рекурсии:
```javascript
function factorial(n) {
  if (n === 1) { // Базовый случай
    return 1;
  }
  return n * factorial(n - 1); // Рекурсивный случай
}

console.log(factorial(5)); // Вывод: 120
```
Реализация:
```javascript

 function fibonacci(n) {
  if (n === 0) return 0; // Базовый случай
  if (n === 1) return 1; // Базовый случай
  return fibonacci(n - 1) + fibonacci(n - 2); // Рекурсивный случай
}

console.log(fibonacci(6)); // Вывод: 8
```

## Важные моменты
1. Условие выхода обязательно: Без базового случая рекурсия приведёт к бесконечным вызовам и ошибке "Maximum call stack size exceeded".
2. Рекурсия против итерации: Любую рекурсию можно заменить на цикл (итерацию), что часто экономит память.
3. Хвостовая рекурсия: Особая форма рекурсии, где последний вызов функции — это рекурсивный вызов. Она более эффективна, если оптимизируется компилятором.


### Хвостовая рекурсия

 
```javascript
 
function factorialTailRec(n, acc = 1) {
  if (n === 1) return acc; // Базовый случай
  return factorialTailRec(n - 1, acc * n); // Рекурсивный случай
}

console.log(factorialTailRec(5)); // Вывод: 120
```
- Рекурсия в JavaScript полезна для задач, которые естественно разделяются на подзадачи, но её следует использовать с осторожностью, чтобы избежать проблем с производительностью.

# Closure

## Замыкание (Closure) в JavaScript

**Замыкание (closure)** — это функция, которая "замыкает" в себе доступ к переменным внешней области видимости, даже после того, как внешняя функция завершила выполнение.

## Как это работает?
Когда функция создаётся, она запоминает область видимости, в которой была определена. Даже если эта функция вызывается позже, она может использовать переменные из той области видимости.

## Пример: Замыкание на практике
```javascript
function outerFunction() {
  let outerVariable = "Я из внешней функции";

  function innerFunction() {
    console.log(outerVariable); // Доступ к переменной внешней функции
  }

  return innerFunction;
}

const closureExample = outerFunction();
closureExample(); // Вывод: "Я из внешней функции"
```
### Что происходит здесь:
1. outerFunction создаёт переменную outerVariable и определяет innerFunction.
2. Когда outerFunction завершает выполнение, её локальные переменные обычно уничтожаются.
3. Однако, поскольку мы вернули innerFunction, она "замыкает" область видимости и сохраняет доступ к outerVariable.

- Замыкания для создания приватных данных
- Замыкания используются для реализации данных, которые нельзя напрямую изменить извне.
 ```javascript
function createCounter() {
  let count = 0; // Приватная переменная

  return function () {
    count++; // Доступ к приватной переменной
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```
- Объяснение:
Переменная count недоступна напрямую снаружи.
Доступ к count возможен только через замыкание, возвращённое createCounter.

### Пример с несколькими функциями
Замыкания позволяют создавать уникальные копии данных для разных функций.
 
``` javascript
 
function multiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```
- Объяснение:
Каждое замыкание сохраняет своё значение factor, даже если вызывается в разное время.

### Замыкание и цикл
Замыкания часто используются для сохранения значений в циклах:

 ```Javascript
function createFunctions() {
  let functions = [];

  for (let i = 0; i < 3; i++) {
    functions.push(function () {
      return i;
    });
  }

  return functions;
}

const funcs = createFunctions();
console.log(funcs[0]()); // 0
console.log(funcs[1]()); // 1
console.log(funcs[2]()); // 2
```
- Здесь использование let позволяет создать уникальное значение i для каждой итерации.


## Преимущества замыканий
- Инкапсуляция данных: Приватные переменные доступны только через замыкания.
- Гибкость: Позволяют создавать функции с уникальным поведением на основе сохранённых данных.
Функциональное программирование: Используются для композиции функций и управления состоянием.
## Замыкания — это мощный инструмент в JavaScript, но их следует использовать с осторожностью, чтобы избежать утечек памяти из-за сохранённых ссылок на неиспользуемые данные.